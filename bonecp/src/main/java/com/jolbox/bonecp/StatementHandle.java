package com.jolbox.bonecp;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.concurrent.ConcurrentLinkedQueue;


/**
 * Wrapper around JDBC Statement.
 *
 * @author wallacew
 * @version $Revision$
 */
public class StatementHandle implements Statement{
	/** Set to true if the connection has been "closed". */
	private volatile boolean logicallyClosed = false;
	/** A handle to the actual statement. */
	protected Statement internalStatement;
	/** List of resultSet that will be closed when this preparedStatement is logically closed. */ 
	private ConcurrentLinkedQueue<ResultSet> resultSetHandles = new ConcurrentLinkedQueue<ResultSet>();
	/** SQL Statement used for this statement. */
	protected String sql;
	/** Cache pertaining to this statement. */
	protected IStatementCache cache;
	/** Handle to the connection holding this statement. */
	protected ConnectionHandle connectionHandle;
	/**
	 * Constructor to statement handle wrapper. 
	 *
	 * @param internalStatement handle to actual statement instance.
	 * @param sql sql statement used for this handle.
	 * @param cache Cache handle 
	 * @param connectionHandle Handle to the connection
	 */
	public StatementHandle(Statement internalStatement, String sql, IStatementCache cache, ConnectionHandle connectionHandle) {
		this.internalStatement = internalStatement;
		this.sql = sql;
		this.cache = cache;
		this.connectionHandle = connectionHandle;
	}


	/**
	 * Constructor for empty statement (created via connection.createStatement) 
	 *
	 * @param internalStatement wrapper to statement
	 * @param connectionHandle Handle to the connection that this statement is tied to.
	 */
	public StatementHandle(Statement internalStatement, ConnectionHandle connectionHandle) {
		this.internalStatement = internalStatement;
		this.connectionHandle = connectionHandle;
		this.sql = null;
		this.cache = null;
	}


	@Override
	public void close() throws SQLException {
		if (!this.logicallyClosed){
			this.logicallyClosed = true;

			ResultSet rs = null;
			while ((rs=this.resultSetHandles.poll()) != null) {
				rs.close();
			}
			if (this.cache != null){
				this.cache.put(this.sql, this);
			}

		}
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#addBatch(java.lang.String)
	 */
	@Override
	public void addBatch(String sql)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.addBatch(sql);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * Checks if the connection is marked as being logically open and throws an exception if not.
	 * @throws SQLException if connection is marked as logically closed.
	 * 
	 *
	 */
	protected void checkClosed() throws SQLException {
		if (this.logicallyClosed) {
			throw new SQLException("Statement is closed");
		}
	}



	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#cancel()
	 */
	@Override
	public void cancel()
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.cancel();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#clearBatch()
	 */
	@Override
	public void clearBatch()
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.clearBatch();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#clearWarnings()
	 */
	@Override
	public void clearWarnings()
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.clearWarnings();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#execute(java.lang.String)
	 */
	@Override
	public boolean execute(String sql)
	throws SQLException {
		boolean result = false;
		checkClosed();
		try {
			result = this.internalStatement.execute(sql);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#execute(java.lang.String, int)
	 */
	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
	throws SQLException {
		boolean result = false;
		checkClosed();
		try{
			result = this.internalStatement.execute(sql, autoGeneratedKeys);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#execute(java.lang.String, int[])
	 */
	@Override
	public boolean execute(String sql, int[] columnIndexes)
	throws SQLException {
		boolean result = false;
		checkClosed();
		try{
			result = this.internalStatement.execute(sql, columnIndexes);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#execute(java.lang.String, java.lang.String[])
	 */
	@Override
	public boolean execute(String sql, String[] columnNames)
	throws SQLException {
		boolean result = false;
		checkClosed();
		try{
			result = this.internalStatement.execute(sql, columnNames);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeBatch()
	 */
	@Override
	public int[] executeBatch()
	throws SQLException {
		int[] result = null;
		checkClosed();
		try{
			result = this.internalStatement.executeBatch();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; // never reached

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeQuery(java.lang.String)
	 */
	@Override
	public ResultSet executeQuery(String sql)
	throws SQLException {
		ResultSet result = null;
		checkClosed();
		try{
			result = trackResultSet(this.internalStatement.executeQuery(sql));
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;

	}

	/**
	 * Adds the given resultset to a list.
	 *
	 * @param rs ResultSet to keep track of
	 * @return rs
	 */
	private ResultSet trackResultSet(ResultSet rs) {
		if (rs != null){
			this.resultSetHandles.add(rs);
		}
		return rs;
	}



	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeUpdate(java.lang.String)
	 */
	@Override
	public int executeUpdate(String sql)
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.executeUpdate(sql);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int)
	 */
	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.executeUpdate(sql, autoGeneratedKeys);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int[])
	 */
	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.executeUpdate(sql, columnIndexes);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#executeUpdate(java.lang.String, java.lang.String[])
	 */
	@Override
	public int executeUpdate(String sql, String[] columnNames)
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.executeUpdate(sql, columnNames);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getConnection()
	 */
	@Override
	public Connection getConnection()
	throws SQLException {
		checkClosed();
		return this.connectionHandle;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getFetchDirection()
	 */
	@Override
	public int getFetchDirection()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getFetchDirection();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getFetchSize()
	 */
	@Override
	public int getFetchSize()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getFetchSize();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getGeneratedKeys()
	 */
	@Override
	public ResultSet getGeneratedKeys()
	throws SQLException {
		ResultSet result = null;
		checkClosed();
		try{
			result = trackResultSet(this.internalStatement.getGeneratedKeys());
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getMaxFieldSize()
	 */
	@Override
	public int getMaxFieldSize()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getMaxFieldSize();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getMaxRows()
	 */
	@Override
	public int getMaxRows()
	throws SQLException {
		int result=0;
		checkClosed();
		try{
			result = this.internalStatement.getMaxRows();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}


	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getMoreResults()
	 */
	@Override
	public boolean getMoreResults()
	throws SQLException {
		boolean result = false;
		checkClosed();
		try{
			result = this.internalStatement.getMoreResults();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getMoreResults(int)
	 */
	@Override
	public boolean getMoreResults(int current)
	throws SQLException {
		boolean result = false;
		checkClosed();

		try{ 
			result = this.internalStatement.getMoreResults(current);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getQueryTimeout()
	 */
	@Override
	public int getQueryTimeout()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getQueryTimeout();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getResultSet()
	 */
	@Override
	public ResultSet getResultSet()
	throws SQLException {
		ResultSet result = null;
		checkClosed();
		try{
			result = trackResultSet(this.internalStatement.getResultSet());
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getResultSetConcurrency()
	 */
	@Override
	public int getResultSetConcurrency()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getResultSetConcurrency();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getResultSetHoldability()
	 */
	@Override
	public int getResultSetHoldability()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getResultSetHoldability();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getResultSetType()
	 */
	@Override
	public int getResultSetType()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getResultSetType();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getUpdateCount()
	 */
	@Override
	public int getUpdateCount()
	throws SQLException {
		int result = 0;
		checkClosed();
		try{
			result = this.internalStatement.getUpdateCount();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#getWarnings()
	 */
	@Override
	public SQLWarning getWarnings()
	throws SQLException {
		SQLWarning result = null;
		checkClosed();
		try{
			result = this.internalStatement.getWarnings();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#isClosed()
	 */
	@Override
	public boolean isClosed()
	throws SQLException {

		return this.logicallyClosed;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#isPoolable()
	 */
	@Override
	public boolean isPoolable()
	throws SQLException {
		boolean result = false;
		checkClosed();
		try{
			result = this.internalStatement.isPoolable();
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result; 

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setCursorName(java.lang.String)
	 */
	@Override
	public void setCursorName(String name)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setCursorName(name);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setEscapeProcessing(boolean)
	 */
	@Override
	public void setEscapeProcessing(boolean enable)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setEscapeProcessing(enable);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setFetchDirection(int)
	 */
	@Override
	public void setFetchDirection(int direction)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setFetchDirection(direction);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setFetchSize(int)
	 */
	@Override
	public void setFetchSize(int rows)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setFetchSize(rows);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setMaxFieldSize(int)
	 */
	@Override
	public void setMaxFieldSize(int max)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setMaxFieldSize(max);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setMaxRows(int)
	 */
	@Override
	public void setMaxRows(int max)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setMaxRows(max);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setPoolable(boolean)
	 */
	@Override
	public void setPoolable(boolean poolable)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setPoolable(poolable);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Statement#setQueryTimeout(int)
	 */
	@Override
	public void setQueryTimeout(int seconds)
	throws SQLException {
		checkClosed();
		try{
			this.internalStatement.setQueryTimeout(seconds);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Wrapper#isWrapperFor(java.lang.Class)
	 */
	@Override
	public boolean isWrapperFor(Class<?> iface)
	throws SQLException {
		boolean result = false;
		try{
			result = this.internalStatement.isWrapperFor(iface);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see java.sql.Wrapper#unwrap(java.lang.Class)
	 */
	@Override
	public <T> T unwrap(Class<T> iface)
	throws SQLException {
		T result = null;
		try{
			result = this.internalStatement.unwrap(iface);
		} catch (SQLException e) {
			this.connectionHandle.markPossiblyBroken(e);
			throw e;
		}
		return result;

	}



	/**
	 * @throws SQLException 
	 * 
	 *
	 */
	public void internalClose() throws SQLException {
		this.internalStatement.close();
		if (this.cache != null){
			this.cache.clear();
		}
	}


	/**
	 * Marks this statement as being "open"
	 *
	 */
	public void setLogicallyOpen() {
		this.logicallyClosed = false;
	}

}
