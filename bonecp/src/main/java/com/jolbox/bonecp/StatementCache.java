/*

Copyright 2009 Wallace Wadge

This file is part of BoneCP.

BoneCP is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

BoneCP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with BoneCP.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.jolbox.bonecp;

import java.sql.SQLException;
import java.sql.Statement;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentMap;

import com.google.common.collect.MapMaker;


/**
 * JDBC statement cache.
 *
 * @author wallacew
 */
public class StatementCache implements IStatementCache {

	/** The cache of our statements. */
	private ConcurrentMap<Object, BlockingQueue<Statement>> cache;
	/** No of entries cached per connection. */
	private int statementsCachedPerConnection;
	/** How many items to cache. */
	private int cacheSize;


	/**
	 * Creates a statement cache of given size. 
	 *
	 * @param size of cache.
	 * @param statementsCachedPerConnection No of entries cached per connection
	 */
	public StatementCache(int size, int statementsCachedPerConnection){
		this.cache = new MapMaker()
		.concurrencyLevel(32)
		.makeMap();

		this.cacheSize = size;
		this.statementsCachedPerConnection = Math.max(1, statementsCachedPerConnection);
	}

	/** Simply appends the given parameters and returns it to obtain a cache key
	 * @param sql
	 * @param resultSetConcurrency
	 * @param resultSetHoldability
	 * @param resultSetType
	 * @return cache key to use
	 */
	public String calculateCacheKey(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability){
		StringBuffer tmp = calculateCacheKeyInternal(sql, resultSetType,
				resultSetConcurrency);

		tmp.append(", H:");
		tmp.append(resultSetHoldability);

		return tmp.toString();
	}

	/** Cache key calculation.
	 * @param sql string
	 * @param resultSetType
	 * @param resultSetConcurrency
	 * @return cache key
	 */
	public String calculateCacheKey(String sql, int resultSetType, int resultSetConcurrency){
		StringBuffer tmp = calculateCacheKeyInternal(sql, resultSetType,
				resultSetConcurrency);

		return tmp.toString();
	}

	/** Cache key calculation.
	 * @param sql
	 * @param resultSetType
	 * @param resultSetConcurrency
	 * @return cache key
	 */
	private StringBuffer calculateCacheKeyInternal(String sql,
			int resultSetType, int resultSetConcurrency) {
		StringBuffer tmp = new StringBuffer(sql.length()+20);
		tmp.append(sql);

		tmp.append(", T");
		tmp.append(resultSetType);
		tmp.append(", C");
		tmp.append(resultSetConcurrency);
		return tmp;
	}


	/** Alternate version of autoGeneratedKeys.
	 * @param sql
	 * @param autoGeneratedKeys
	 * @return cache key to use.
	 */
	public String calculateCacheKey(String sql, int autoGeneratedKeys) {
		StringBuffer tmp = new StringBuffer(sql.length()+4);
		tmp.append(sql);
		tmp.append(autoGeneratedKeys);
		return tmp.toString();
	}

	/** Calculate a cache key.
	 * @param sql to use
	 * @param columnIndexes to use
	 * @return cache key to use.
	 */
	public String calculateCacheKey(String sql, int[] columnIndexes) {
		StringBuffer tmp = new StringBuffer(sql.length()+4);
		tmp.append(sql);
		for (int i=0; i < columnIndexes.length; i++){
			tmp.append(columnIndexes[i]);
			tmp.append("CI,");
		}
		return tmp.toString();
	}

	/** Calculate a cache key.
	 * @param sql to use
	 * @param columnNames to use
	 * @return cache key to use.
	 */
	public String calculateCacheKey(String sql, String[] columnNames) {
		StringBuffer tmp = new StringBuffer(sql.length()+4);
		tmp.append(sql);
		for (int i=0; i < columnNames.length; i++){
			tmp.append(columnNames[i]);
			tmp.append("CN,");
		}
		return tmp.toString();

	}

	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#get(java.lang.String)
	 */
	@Override
	public Statement get(String key){
		Statement result = null;
		BlockingQueue<Statement> statementCache = this.cache.get(key);

		if (statementCache != null) {
			result = statementCache.poll();
		}
		if (result != null){
			((StatementHandle)result).inCache.set(false);
		}
		return result;
	}

	@Override
	public Statement get(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) {
		return get(calculateCacheKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}


	@Override
	public Statement get(String sql, int resultSetType, int resultSetConcurrency) {
		return get(calculateCacheKey(sql, resultSetType, resultSetConcurrency));
	}

	@Override
	public Statement get(String sql, int autoGeneratedKeys) {
		return get(calculateCacheKey(sql, autoGeneratedKeys));
	}


	@Override
	public Statement get(String sql, int[] columnIndexes) {
		return get(calculateCacheKey(sql, columnIndexes));
	}


	@Override
	public Statement get(String sql, String[] columnNames) {
		return get(calculateCacheKey(sql, columnNames));
	}



	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#put(java.lang.String, java.sql.Statement)
	 */
	@Override
	public void put(String key, Statement value) throws SQLException{
		if (this.cache.size() <=  this.cacheSize && ((StatementHandle)value).inCache.compareAndSet(false, true)){ // perhaps use LRU in future?? Worth the overhead? Hmm....
			// now add to our cache
			BlockingQueue<Statement> queue = new ArrayBlockingQueue<Statement>(this.statementsCachedPerConnection);
			BlockingQueue<Statement> statementCache = this.cache.putIfAbsent(key, queue);
			if (statementCache != null) {
				queue = statementCache;
			}

			// save this if you can
			if (!queue.offer(value)){
				// but if you can't, just throw it away after closing
				((StatementHandle)value).internalClose(); 
			}
		}
	}


	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#size()
	 */
	@Override
	public int size(){
		return this.cache.size();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#sizeOfQueue(java.lang.String)
	 */
	@Override
	public int sizeOfQueue(String sql){
		return this.cache.get(sql).size();
	}

	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#remove(java.lang.String)
	 */
	@Override
	public void remove(String sql) {
		this.cache.remove(sql);
	}


	/**
	 * {@inheritDoc}
	 *
	 * @see com.jolbox.bonecp.IStatementCache#clear()
	 */
	@Override
	public void clear() {
		this.cache.clear();
	}

}
